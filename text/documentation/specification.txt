#!/usr/bin/env eclectic

======================
[ Eclectic Text File ]
======================

The `.txt` extension should be used for eclectic text. It is strictly
a format layered on top of raw text files. Whether or not a given text file
is actually eclectic text should be determined by the context or by
the initial `#!` line used to identify a corresponding binary.

===============
[ Declaration ]
===============

Eclectic text formatting is explicitly declared by the initial line in the document
being: `#!/usr/bin/env eclectic`. This is a special case of the notation used by
&[Literal Blocks]; if the first line of a given document starts with `#!`, it is perceived
as a declaration instead of a literal block.

===============
[ Decorations ]
===============

Decoration events are produced by lines surrounded with arbitrary whitescpace that contain
the same characters. Decorations can be made up of arbitrary characters and can be used
to decorate titles, emphasize line ranges, or provide some anticipated visual padding.

Decorations are normally ignored during serialization as they are primarily used for
the visual purposes inside the source text.

-----------------------
-----------------------

The class of characters are irrevelant, lines that only consist of the same characters are
considered decoration *unless* the line is only a single character. The distinction is
allowed as it may be possible for a sentence to require its period to be placed on
the following line due to width constraints.

Example:

aaaaaaaaaaaaaaaaa
bbbbbbbbbbbbbbbbb
ccccccccccccccccc
=-=-=-=-=-=-=-=-=
|--==--==--==--|

It's important that short lines are not misperceived as decorations, so minimums in
decoration line length and maximums in repetition characters are used to help avoid ambiguity.
By default, a line must have more than one character in order to be perceived as a
decoration, and must have no more than four characters of the same identity.
Additionally, decorations only apply to paragraph processing; &Literal-Blocks will
never identify a line as a decoration.

Here, text should be seen literally, and identification of decorations should not happen:
#!/quote

	-----------
	bb
	-=-=-=-=-=-
	aa
	|--==--==--==--|
	aaaaaaaaaaa

Decorations are supported primarily for section title decoration. INI-section titles
do not visually standout very well on their own, so decorations are supported to allow
emphasis of their presence.

============
[ Sections ]
============

Sections make up the primary hierarchical structure in eclectic text formatted documents
and are notated in the fashion that ".ini" configuration files notate sections: lines
starting with (character)`[` and ending with (character)`]` select the section context.

Sections *must* be addressable by their title name. References have syntax to disambiguate
section references from regular references in order to accommodate local references.

Subsections are managed by the use of a double greater-than, `>>`, separator in the
section's title text. A section with `>>` in the title identifies the section as being
contained by another; (character)`>>` being used as a path delimiter. In order to allow
interleaving section content with subsection content, the section may be chosen by repeating
the creation of a section with the same title.

In addition to providing support for subsections, allowing a section to be re-entered at
arbitrary points provides a mechanism to avoid title conflicts. Sections are selected or
created by the Section Notation.

When the section context is switched, a new section is created or an existing is selected
for new content to be added.

[ Sections >> Example ]

#!/text/eclectic
	[ Containing Section ]

	Root Section content.

	[ Containing Section >> Subsection ]

	Subsection Content

	[ Containing Section ]

	Continuation of &[Containing Section].

	[ Containing Section >> Subsequent Subsection ]

	Second subsection

=====================
[ Paragraph Context ]
=====================

Paragraph lines are the default effect of a text line inside an eclectic document;
they are implicitly created which is unlike most other structures that are initiated
by command codes (operators borrowed from other languages and contexts).

===================
[ Literal Context ]
===================

Literal lines are the lines contained within indentation blocks following the block
command, `#!`. The notation is borrowed from UNIX executable files which define the
binary that should be used to "execute" the given file.

===================
[ Inline Literals ]
===================

Inline literals are literal text ranges existing in paragraph lines delimited using
the grave accent, also known as a "backtick". Its syntax is borrowed from one of the
Bourne Shell's notations for command substitution. It was also chosen for its
similarity to quotations which are often used in programming languages to refer to literal
text.

#!/text/eclectic
	`Inline Literal`

Inline literals are the first parts of a paragraph line to be extracted; all other notations
have lower precedence and cannot contain grave accents themselves. Literal accents can
be interpolated using &References, `&~grave-accent`.

==============
[ Directives ]
==============

Directives are identified using the at-sign, (character)`@`, at the beginning of the line
containing the details of the directive.

Directives are primarily used to define alternate identifiers for document structures, but
can also be used to send messages to the processing context to control presentation of the
associated structure.

#!/text/eclectic
	@custom_section_address
	[ Section ]

#!/text/eclectic
	@paragraph_address
	First Paragraph

	Second Paragraph

Spaces in address declarations are used to separate the address from additional configuration.

Addresses are local to the context in which they are declared. Addresses inside sections are scoped
to that section unless explicitly declared as global.

==============
[ References ]
==============

References are paragraph elements whose notation is borrowed from the C programming
language's address-of operator, the ampersand `&`. The endpoint of a reference is
wholly determined by the processing context; while, IRIs and section references are usually
mapped consistently across implementations, the processing context ultimately
determines the actual meaning of *all* references.

References begin with an ampersand, (text)`&`, and usually end with whitespace.
Punctuation characters may exist inside references, but trailing punctuation *must*
be perceived as regular text in order to accommodate for the default purpose of the
punctuation.

However, Section References are enclosed in brackets in order to allow whitespace.

#!/text/eclectic

	A sentence containing a reference at the end, &Reference.

Like inline literals, references may be casted in order to select the namespace set that
the reference is pertaining to: `(cast)&Reference`. Whitespace may not be present between
the parenthesis and the reference's ampersand. Rather, the adjacency of the closing
parenthesis identifies the reference as being modified by a cast.


A Hyperlink: &<Substitution Text URL>

=============
[ Citations ]
=============

Citations are managed using &References to locally defined addresses.
Most addresses are defined as pointers to specific document nodes, but citations
allow reuse of a given address.

#!/text/eclectic

	A citation[&Address-Name] is a reference to a defined address that can
	be found in a specially not citations section.

	[#References]
	/ReferenceName
		&<http://docs.fault.io/>

==================
[ Literal Blocks ]
==================

Literal blocks are used for multi-line formatting escapes such as source code examples,
and block quotes. Literal blocks are initiated by the (quote)`#!` command. The command is
associated with a parameter defining the format of the contents.

#!/pl/python
	import fault

Literal block declaration parameters that begin with a (quote)`/` identify the block's
type ambiguously such that the processor must reconcile its meaning. Declaration parameters
that begin without a leading forward slash are Internet Media Types and subject to the
constraints of that standardized format with exception to the encoding as transformations
may need to take place in order to identify conformance.

============
[ Emphasis ]
============

The syntax of emphasis is borrowed from a number of structured text
implementations on the internet, the asterisk: (quote)`*`. The level of
emphasis is determined by repetition of the asterisk. Emphasis is terminated
in the same way that it's started, with another asterisk of the same repetition.
Processors and serialization should recognize arbitrary levels of emphasis even though
only two levels are normally used.

#!/text/eclectic

	A paragraph line with *emphasis* around the word emphasis.
	Greater emphasis is placed with more **asterisks**.

By default, emphasis of one asterisk *should* be mapped to italics,
and emphasis of two asterisks *should* be mapped to bold.

=========
[ Lists ]
=========

Enumerated lists are notated using the hash symbol: (quote)`#`. It is borrowed 
from the shell comment character and used due to its name "the number sign".
With exception to indentation, leading whitespace is ignored in order to allow
a horizontal visual separation from adjacent paragraphs.

#!/text/ecelctic
	...
		# First Item.
		# Second Item.
		# Third Item.
	...

Unordered lists are represented by a series of lines that start with the subtraction
operator: (quote)`-`.
Like emphasis, the notation is borrowed from other structured text implementations.

Unlike many other structured text solutions, other notations such as asterisks or periods
are not supported.

#!/text/eclectic

	...
		- Simple single item.
		- Complicated Multiline items are supported using continuation commands.
		- Spaces before the command code is allowed for visual appeal.
	...

Enumerated lists and unordered lists share the same formatting features. The only distinction
between the two is their identification in the tokenized or structured representation.

Lists have one particular requirement: they must be indented from the context paragraph.
Lists use indentation to resolve ambiguity about their structure in situations of nested
lists.

==================
[ Variable Lists ]
==================

Variable lists (finite mappings or dictionaries) are supported using the forward slash:
(quote)`/`. The notation is borrowed from UNIX filesystem paths where the forword slash
delimits directory names in a path to a particular file. Directory entries point to file
content in the same way that variable list items point to eclectic content. Structurally,
the XML schema identify &[Variable Lists] as &.schema.dictionary.

#!/text/eclectic

	/Variable Entry
		Paragraph Content

	/Another Variable Entry
		Paragraph Content

Variable list items *should* be referrable *if* the list is given an address.
Anonymous variable lists have no reference point and, therefore, the items cannot
be referenced.

============
[ Matrices ]
============

Tables are called matrices in eclectic text regardless of the content type.
Matrices are supported using unicode's box characters:

#!/text

	┌─┬─┬─┐
	│ │ │ │
	├─┼─┼─┤
	│ │ │ │
	├─┼─┼─┤
	│ │ │ │
	└─┴─┴─┘

Bold box frames are used to denote column headers:

#!/text

	┏━┳━┳━┓
	┃ ┃ ┃ ┃
	┡━╇━╇━┩
	│ │ │ │
	├─┼─┼─┤
	│ │ │ │
	└─┴─┴─┘

Box characters are used to avoid overloading other more common ASCII characters.
Essentially, eclectic is relying on users to find tools to manage
formatting of matrices.

===============
[ Admonitions ]
===============

Admonition notation is borrowed from math's notation for factorials, (syntax)`!`.
Admonitions consist of a severity and a following sequence of paragraphs
indented on the lines following:

#!/text/eclectic

	! WARNING:
		Warning Contents.

The severity (word following the (syntax)`!`) is an arbitrary word usually one
of: `WARNING`, `NOTE`, `ERROR`, `DANGER`, `DEVELOPER`, and `RECOMMENDATION`.

Admonitions consist of arbitrary section content. This means that
lists, blocks, and even inner admonitions may appear.

! NOTE:
	Note admonition.
! WARNING:
	Warning admonition.
! DEVELOPER:
	Admonition intended for developers.
! RECOMMENDATION:
	Recommendation.
! ERROR:
	Admonition noting an error.

=========
[ Casts ]
=========

Casting is a concept borrowed from the C programming language along
with its syntax, a parenthetical prefix. Casts are distinguished from
regular parenthesis by the absence of whitespace padding. So,
`(parenthetical) words` will not be identified as a cast whereas,
`(parenthetical)words` will be.

Casts are primarily useful with &Inline-Literals as they allow the context
to determine the meaning of the content of the literal without the author
having to consider eclectic syntax inside the literal.

(iri)`http://fault.io`
&<http://fault.io>

Paragraph with `anonymous inline code` that defaults the language.
&<Hyperlink=https://fault.io>
&<https://fault.io>

==================
[ Reserved Casts ]
==================

Conceptual type names are reserved for contextually defined purposes.

/text
	An arbitrary sequence of characters making up text. Normally represented by the
	context as UNICODE characters.

/integer or int
	A string that represents a negative or positive number.
	`0b`, `0o`, and `0x` can be used to identify the base and a preceding `+` or `-` minus
	identifies whether it is positive or negative.

/real
	A string that represents a Real Number

===========================
[ Structured Data Storage ]
===========================

Primarily, eclectic is intended for documentation purposes, but with casts and addressable
structures, it can also be used as configuration files.

Application configuration without documentation is opaque for most software. Being able
to package them together provides convenience for the user and the developer.

/`string-key`
	# &1
	# &2
	# &3
/&0
	Key is the number zero.
	The value here is paragraph text with placeholder references:
	(reference)&!param-name.

==============
[ Exceptions ]
==============

/Unbalanced Title
	`[[ Section Name]`

/Invalid Reference
	`&jvisnlw.ndivjkr`

===========
[ Grammar ]
===========

This section defines the normative grammar for eclectic markdown.

#!/text/grammar

	newline := "\\n"
	whitespace := (" " | "\\t" | newline)*

	section-title := paragraph-content
	section-titles := section-title (">>" section-title)*
	section-select := ("[")* section-titles ("]")*
	section-content := (paragraph | list | block)*

	root := head (title section)*
	head := section
	inline-literal := ("`" text "`", cast)
	reference := (cast?, "&" text)
	paragraph := (text | reference | inline-literal)*
	set := ((newline whitespace "-" whitespace, paragraph))
	enumeration := ((newline whitespace "#" whitespace, paragraph))
	variable-identity := (newline whitespace "/" paragraph
	variable-data := paragraph
	variables := ((variable-identity, variable-data))*
	list := (enumeration* | set* | variables*)

	declaration := text
	block := (declaration, (literal-lines)*)

[ Queries ]

@=Ref
	# String-1
	# String-2
	# String-3

@=SetRef
	- String-1
	- String-2
	- String-3

@=identifier
@query
@matrix
@context pq://db.ltld/dbname/ns/table

/column-1
	&func
		# &param-1
		# &param-2

/column-2
	Expression.

/column-3
	Expression.
