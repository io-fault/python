/**
	// &.kernel.Event interfaces.
*/
#ifndef _SYSTEM_KERNEL_EVENT_H_included_
#define _SYSTEM_KERNEL_EVENT_H_included_

#define EV_CYCLIC 1

/**
	// Events that are generated by scheduler operations.
*/
#define EVENT_TYPE_META_LIST() \
	EV_TYPE(meta_actuate, ev_reference, !EV_CYCLIC) \
	EV_TYPE(meta_exception, ev_reference, EV_CYCLIC) \
	EV_TYPE(meta_terminate, ev_reference, !EV_CYCLIC)

/**
	// Time events.
*/
#define EVENT_TYPE_TIME_LIST() \
	EV_TYPE(never, ev_reference, !EV_CYCLIC) \
	EV_TYPE(time, ev_time_units, !EV_CYCLIC)

/**
	// IPC related.
*/
#define EVENT_TYPE_IP_LIST() \
	EV_TYPE(process_signal, ev_signal_reference, EV_CYCLIC) \
	EV_TYPE(process_exit, ev_pid_reference, !EV_CYCLIC)

/**
	// Events generated from filesystem operations.
*/
#define EVENT_TYPE_FS_LIST() \
	EV_TYPE(fs_status, ev_filesystem_reference, EV_CYCLIC) \
	EV_TYPE(fs_delta, ev_filesystem_reference, EV_CYCLIC) \
	EV_TYPE(fs_void, ev_filesystem_reference, !EV_CYCLIC)

/**
	// I/O for transferring octets, sockets, and datagrams.
*/
#define EVENT_TYPE_IO_LIST() \
	EV_TYPE(io_status, ev_io_reference, EV_CYCLIC) \
	EV_TYPE(io_receive, ev_io_reference, EV_CYCLIC) \
	EV_TYPE(io_transmit, ev_io_reference, EV_CYCLIC)

/**
	// Macro list of event types.
*/
#define EVENT_TYPE_LIST() \
	EVENT_TYPE_META_LIST() \
	EVENT_TYPE_TIME_LIST() \
	EVENT_TYPE_IP_LIST() \
	EVENT_TYPE_FS_LIST() \
	EVENT_TYPE_IO_LIST()

/**
	// Enumeration of &EVENT_TYPE_LIST.
*/
#define EV_TYPE_ID(NAME) evt_##NAME
enum EventType {
	evt_invalid = 0,
	#define EV_TYPE(NAME, C, CYCLIC) EV_TYPE_ID(NAME),
		EVENT_TYPE_LIST()
	#undef EV_TYPE
};

static inline const char *
ev_type_name(enum EventType etyp)
{
	switch (etyp)
	{
		#define EV_TYPE(NAME, C, CYCLIC) \
			case EV_TYPE_ID(NAME): \
				return(#NAME); \
			break;

			EVENT_TYPE_LIST()
		#undef EV_TYPE
	}

	return("invalid");
}

static inline enum EventType
ev_type_code(const char *n)
{
	#define _SHIFT(B,O) (B << O)
	#define STRSHIFT(a) \
		(_SHIFT(a[0],24)|_SHIFT(a[1],16)|_SHIFT(a[2],8)|_SHIFT(a[3],0))
	#define STRCASE(a,b,c,d) \
		(_SHIFT(a,24)|_SHIFT(b,16)|_SHIFT(c,8)|_SHIFT(d,0))

	uint32_t init;
	char buf[4] = {0,0,0,0,};
	const char *ext = &n[3];

	strncpy(buf, n, 3);
	init = STRSHIFT(buf);

	switch (init)
	{
		case STRCASE('i','o','-','\0'):
		case STRCASE('i','o','_','\0'):
		{
			if (strcmp(ext, "receive") == 0)
				return(EV_TYPE_ID(io_receive));
			else if (strcmp(ext, "transmit") == 0)
				return(EV_TYPE_ID(io_transmit));
		}
		break;

		case STRCASE('f','s','-','\0'):
		case STRCASE('f','s','_','\0'):
		{
			if (strcmp(ext, "delta") == 0)
				return(EV_TYPE_ID(fs_delta));
			else if (strcmp(ext, "void") == 0)
				return(EV_TYPE_ID(fs_void));
			else if (strcmp(ext, "status") == 0)
				return(EV_TYPE_ID(fs_status));
		}
		break;

		case STRCASE('m','e','t','\0'):
		{
			/* meta[-_] */
			if (ext[0] == 'a' && (ext[1] == '-' || ext[1] == '_'))
			{
				ext = &ext[2];

				if (strcmp(ext, "actuate") == 0)
					return(EV_TYPE_ID(meta_actuate));
				else if (strcmp(ext, "terminate") == 0)
					return(EV_TYPE_ID(meta_terminate));
				else if (strcmp(ext, "exception") == 0)
					return(EV_TYPE_ID(meta_exception));
			}
		}

		case STRCASE('t','i','m','\0'):
			if (strcmp(ext, "e") == 0)
				return(EV_TYPE_ID(time));
		break;

		case STRCASE('n','e','v','\0'):
			if (strcmp(ext, "er") == 0)
				return(EV_TYPE_ID(never));
		break;

		case STRCASE('p','r','o','\0'):
			if (strcmp(ext, "cess_exit") == 0)
				return(EV_TYPE_ID(process_exit));
		break;

		case STRCASE('s','i','g','\0'):
			if (strcmp(ext, "nal") == 0)
				return(EV_TYPE_ID(process_signal));
		break;

		default:
			return(EV_TYPE_ID(invalid));
		break;
	}

	return(EV_TYPE_ID(invalid));
	#undef STRSHIFT
	#undef STRCASE
	#undef _SHIFT
}

typedef struct EventSpecification event_t;
struct EventSpecification {
	enum EventType evs_type;

	PyObj evs_source;
	kport_t evs_kresource;

	/* Determined by evs_type */
	union {
		uint64_t time;
		pid_t process;
		int signal_code;
		kport_t correlation;
	} evs_field;

	uint8_t evs_terminal[0];
};

static inline int
evs_type_name(struct EventSpecification *evs, const char **typname)
{
	*typname = NULL;

	switch (evs->evs_type)
	{
		#define EV_TYPE(NAME, C, CYCLIC) \
			case EV_TYPE_ID(NAME): \
				*typname = #NAME; \
			break;

			EVENT_TYPE_LIST()
		#undef EV_TYPE

		default:
			*typname = "invalid";
			return(-1);
		break;
	}

	return(0);
}

static inline const char *
evs_type_identifier(struct EventSpecification *evs)
{
	switch (evs->evs_type)
	{
		#define EV_TYPE(NAME, C, CYCLIC) \
			case EV_TYPE_ID(NAME): \
				return("evt_" #NAME); \
			break;

			EVENT_TYPE_LIST()
		#undef EV_TYPE

		default:
			return("evt_invalid");
		break;
	}
}

#define Event_Specification(EV) (&EV->ev_spec)
#define Event_Type(EV) (Event_Specification(EV)->evs_type)

#define Event_GetSource(EV) (EV->ev_spec.evs_source)
#define Event_GetKPort(EV) (EV->ev_spec.evs_kresource)
#define Event_GetTime(EV) (EV->ev_spec.evs_field.time)
#define Event_GetProcess(EV) (EV->ev_spec.evs_field.process)
#define Event_GetSignal(EV) (EV->ev_spec.evs_field.signal_code)
#define Event_GetCorrelation(EV) (EV->ev_spec.evs_field.correlation)

#define Event_SetSource(EV, OB) (Event_GetSource(EV) = OB)
#define Event_SetKPort(EV, KP) (Event_GetKPort(EV) = KP)
#define Event_SetTime(EV, TIME) (Event_GetTime(EV) = TIME)
#define Event_SetProcess(EV, PROCID) (Event_GetProcess(EV) = PROCID)
#define Event_SetSignal(EV, SIG) (Event_GetSignal(EV) = SIG)
#define Event_SetCorrelation(EV, KP) (Event_GetCorrelation(EV) = KP)

typedef struct Event *Event;
struct Event {
	PyObject_HEAD
	event_t ev_spec;
};
extern PyTypeObject EventType;
#endif
