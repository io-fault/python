/**
	// &.kernel.Event interfaces.
*/
#ifndef _SYSTEM_KERNEL_EVENT_H_included_
#define _SYSTEM_KERNEL_EVENT_H_included_

/**
	// Events that are generated by scheduler operations.
*/
#define EVENT_TYPE_META_LIST() \
	EV_TYPE(meta_actuate, ev_reference) \
	EV_TYPE(meta_terminate, ev_reference)

/**
	// Time events.
*/
#define EVENT_TYPE_TIME_LIST() \
	EV_TYPE(never, ev_reference) \
	EV_TYPE(time, ev_nanoseconds)

/**
	// IPC related.
*/
#define EVENT_TYPE_IP_LIST() \
	EV_TYPE(process_signal, ev_signal_reference) \
	EV_TYPE(process_exit, ev_pid_reference)

/**
	// Events generated from filesystem operations.
*/
#define EVENT_TYPE_FS_LIST() \
	EV_TYPE(fs_status, ev_filesystem_reference) \
	EV_TYPE(fs_delta, ev_filesystem_reference) \
	EV_TYPE(fs_void, ev_filesystem_reference)

/**
	// I/O for transferring octets, sockets, and datagrams.
*/
#define EVENT_TYPE_IO_LIST() \
	EV_TYPE(io_status, ev_io_reference) \
	EV_TYPE(io_receive, ev_io_reference) \
	EV_TYPE(io_transmit, ev_io_reference)

/**
	// Macro list of event types.
*/
#define EVENT_TYPE_LIST() \
	EVENT_TYPE_META_LIST() \
	EVENT_TYPE_TIME_LIST() \
	EVENT_TYPE_IP_LIST() \
	EVENT_TYPE_FS_LIST() \
	EVENT_TYPE_IO_LIST()

/**
	// Enumeration of &EVENT_TYPE_LIST.
*/
#define EV_TYPE_ID(NAME) evt_##NAME
enum EventType {
	evt_invalid = 0,
	#define EV_TYPE(NAME, C) EV_TYPE_ID(NAME),
		EVENT_TYPE_LIST()
	#undef EV_TYPE
};

static inline const char *
ev_type_name(enum EventType etyp)
{
	switch (etyp)
	{
		#define EV_TYPE(NAME, C) \
			case EV_TYPE_ID(NAME): \
				return(#NAME); \
			break;

			EVENT_TYPE_LIST()
		#undef EV_TYPE
	}

	return("invalid");
}

static inline enum EventType
ev_type_code(const char *n)
{
	#define _SHIFT(B,O) (B << O)
	#define STRSHIFT(a) \
		(_SHIFT(a[0],24)|_SHIFT(a[1],16)|_SHIFT(a[2],8)|_SHIFT(a[3],0))
	#define STRCASE(a,b,c,d) \
		(_SHIFT(a,24)|_SHIFT(b,16)|_SHIFT(c,8)|_SHIFT(d,0))

	uint32_t init;
	char buf[4] = {0,0,0,0,};
	const char *ext = &n[3];

	strncpy(buf, n, 3);
	init = STRSHIFT(buf);

	switch (init)
	{
		case STRCASE('i','o','-','\0'):
		case STRCASE('i','o','_','\0'):
		{
			if (strcmp(ext, "receive") == 0)
				return(EV_TYPE_ID(io_receive));
			else if (strcmp(ext, "transmit") == 0)
				return(EV_TYPE_ID(io_transmit));
		}
		break;

		case STRCASE('f','s','-','\0'):
		case STRCASE('f','s','_','\0'):
		{
			if (strcmp(ext, "delta") == 0)
				return(EV_TYPE_ID(fs_delta));
			else if (strcmp(ext, "void") == 0)
				return(EV_TYPE_ID(fs_void));
			else if (strcmp(ext, "status") == 0)
				return(EV_TYPE_ID(fs_status));
		}
		break;

		case STRCASE('m','e','t','\0'):
		{
			/* meta[-_] */
			if (ext[0] == 'a' && (ext[1] == '-' || ext[1] == '_'))
			{
				ext = &ext[2];

				if (strcmp(ext, "actuate") == 0)
					return(EV_TYPE_ID(meta_actuate));
				else if (strcmp(ext, "terminate") == 0)
					return(EV_TYPE_ID(meta_terminate));
			}
		}

		case STRCASE('t','i','m','\0'):
			if (strcmp(ext, "e") == 0)
				return(EV_TYPE_ID(time));
		break;

		case STRCASE('n','e','v','\0'):
			if (strcmp(ext, "er") == 0)
				return(EV_TYPE_ID(never));
		break;

		case STRCASE('p','r','o','\0'):
			if (strcmp(ext, "cess_exit") == 0)
				return(EV_TYPE_ID(process_exit));
		break;

		case STRCASE('s','i','g','\0'):
			if (strcmp(ext, "nal") == 0)
				return(EV_TYPE_ID(process_signal));
		break;

		default:
			return(EV_TYPE_ID(invalid));
		break;
	}

	return(EV_TYPE_ID(invalid));
	#undef STRSHIFT
	#undef STRCASE
	#undef _SHIFT
}

/**
	// Identifies what is stored in a &EventResource union.

	// /evr_kport/
		// One or two file descriptors depending on the event type.
		// For &evt_io, the &EventResource.io array may hold bad file descriptors.
		// For &evt_signal and &evt_process_exit, &EventResource.sigref and
		// &EventResource.procref hold the one file descriptor as the first member.
	// /evr_identifier/
		// Time period, signal, or PID without a kport_t. Used with BSD kqueue.
	// /evr_object/
		// Used by never and some meta events.
	// /evr_obkp_pair/
		// A kport derived using an object. Currently, only used by filesystem events.
*/
enum EventResourceType {
	evr_none = 0,
	evr_identifier = 1,
	evr_object,
	evr_kport,
	evr_obkp_pair, /* Usually kport derived from object. */
};

/**
	// Identifier for the source of produced events.
*/
union EventResource {
	int signal_code;
	struct {
		kport_t sigfd;
		int signal_code;
	} sigref;

	pid_t process;
	struct {
		kport_t procfd;
		pid_t process;
	} procref;

	/* nanoseconds */
	uint64_t time;
	kport_t io[2];

	/* Arbitrary user data used with never and meta_* */
	PyObj ref_object;

	/* kport_t kre allocated from PyObject src */
	struct {
		PyObj src;
		kport_t kre;
	} obkp;
};

typedef struct EventSpecification event_t;
struct EventSpecification {
	enum EventType evs_type;

	enum EventResourceType evs_resource_t;
	union EventResource evs_resource;
	uint8_t evs_terminal[0];
};

static inline int
evs_type_name(struct EventSpecification *evs, const char **typname)
{
	*typname = NULL;

	switch (evs->evs_type)
	{
		#define EV_TYPE(NAME, C) \
			case EV_TYPE_ID(NAME): \
				*typname = #NAME; \
			break;

			EVENT_TYPE_LIST()
		#undef EV_TYPE

		default:
			*typname = "invalid";
			return(-1);
		break;
	}

	return(0);
}

static inline const char *
evs_type_identifier(struct EventSpecification *evs)
{
	switch (evs->evs_type)
	{
		#define EV_TYPE(NAME, C) \
			case EV_TYPE_ID(NAME): \
				return("evt_" #NAME); \
			break;

			EVENT_TYPE_LIST()
		#undef EV_TYPE

		default:
			return("evt_invalid");
		break;
	}
}

#define Event_Specification(EV) (&EV->ev_spec)
#define Event_Type(EV) (Event_Specification(EV)->evs_type)
#define Event_ResourceType(EV) (Event_Specification(EV)->evs_resource_t)
#define Event_Resource(EV) (&Event_Specification(EV)->evs_resource)
#define Event_SetResourceType(EV, RTYPE) Event_ResourceType(EV) = RTYPE
kport_t Event_KPort(event_t *);

typedef struct Event *Event;
struct Event {
	PyObject_HEAD
	event_t ev_spec;
};
extern PyTypeObject EventType;
#endif
